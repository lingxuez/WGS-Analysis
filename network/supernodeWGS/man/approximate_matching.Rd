% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matching.R
\name{approximate_matching}
\alias{approximate_matching}
\title{Approximate matching function}
\usage{
approximate_matching(name1, name2, verbose = T)
}
\arguments{
\item{name1}{vector}

\item{name2}{vector}

\item{verbose}{boolean}
}
\value{
numeric vector
}
\description{
This function creates a vector that is length of \code{name1} where the
\code{i}th element of this vector contains the value (say, called \code{x}) such
that \code{name1[i]} is matched to \code{name2[x]}.
}
\details{
There are few tricks this function does. First, it splits all strings in
\code{name1} and \code{name2} by underscores, (i.e., "_"). Next, it removes
all words with less than 3 characters. Then, all subwords are removed.
(For example, if the two words in the string are "Antisense" and "AntisenseMutation",
the word "Antisense" is removed.)

Assuming there is only one string in both \code{name1} and \code{name2} after
this processing with no words (i.e., empty string), the empty strings are matched
to each other.

Finally, the element in \code{name2} is returned
such 1) this element has the highest percentage
of its words in \code{name1[i]} of all elements in \code{name2}
and 2) \code{name1[i]} has highest percentage of its words in this element
among all elements in \code{name2}.
If no elements satisfy this condition (i.e., the intersection), then
an \code{NA} is returned. Otherwise, if there are more than one element
that satifies this condition, a \code{0} is returned.
}
